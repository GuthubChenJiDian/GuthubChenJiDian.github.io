import{_ as e,c as o,e as r,o as n}from"./app-D7jM77qR.js";const p="/assets/serialization-Cr00Vrqh.png",a="/assets/header-body-DxZDH7N7.png",s={};function c(d,t){return n(),o("div",null,[...t[0]||(t[0]=[r('<h3 id="tcp的特点" tabindex="-1"><a class="header-anchor" href="#tcp的特点"><span>TCP的特点</span></a></h3><p>TCP的三个特点：面向连接、可靠、基于字节流。</p><h3 id="基于字节流" tabindex="-1"><a class="header-anchor" href="#基于字节流"><span>基于字节流</span></a></h3><p>字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 01 串 。纯裸 TCP 收发的这些 01 串之间是 没有任何边界 的，你根本不知道到哪个地方才算一条完整消息。</p><p>这便出现了所谓的<code>粘包问题</code>。</p><p>由于纯裸 TCP 是不能直接拿来用的，所以在这个基础上加入一些 自定义的规则 ，用于区分消息边界 。即消息头和消息体。</p><h3 id="消息头和消息体" tabindex="-1"><a class="header-anchor" href="#消息头和消息体"><span>消息头和消息体</span></a></h3><p>于是我们会把每条要发送的数据都包装一下，比如加入消息头 ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的消息体 。</p><p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 <strong>协议。</strong></p><p>每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong></p><p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p><h3 id="tcp传输的内容" tabindex="-1"><a class="header-anchor" href="#tcp传输的内容"><span>TCP传输的内容</span></a></h3><p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p><p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p><p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p><p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p><img src="'+p+'" alt="序列化" style="zoom:80%;"><p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p><p>截图如下。</p><img src="'+a+'" alt="Header和Body" style="zoom:80%;">',20)])])}const h=e(s,[["render",c]]),g=JSON.parse('{"path":"/note/computer/TCP.html","title":"关于TCP","lang":"zh-CN","frontmatter":{"title":"关于TCP","category":["computer"],"date":"2025-11-26T00:00:00.000Z","pageInfo":["author","Word","readingTime","date","Category","Tag"],"description":"TCP的特点 TCP的三个特点：面向连接、可靠、基于字节流。 基于字节流 字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 01 串 。纯裸 TCP 收发的这些 01 串之间是 没有任何边界 的，你根本不知道到哪个地方才算一条完整消息。 这便出现了所谓的粘包问题。 由于纯裸 TCP 是不能直接拿来用的，所以在这个基础上加入一些 自定义的规则 ，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"关于TCP\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-26T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"马里凡\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/note/computer/TCP.html"}],["meta",{"property":"og:site_name","content":"马里凡"}],["meta",{"property":"og:title","content":"关于TCP"}],["meta",{"property":"og:description","content":"TCP的特点 TCP的三个特点：面向连接、可靠、基于字节流。 基于字节流 字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 01 串 。纯裸 TCP 收发的这些 01 串之间是 没有任何边界 的，你根本不知道到哪个地方才算一条完整消息。 这便出现了所谓的粘包问题。 由于纯裸 TCP 是不能直接拿来用的，所以在这个基础上加入一些 自定义的规则 ，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:published_time","content":"2025-11-26T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.36,"words":707},"filePathRelative":"note/computer/TCP.md","excerpt":"<h3>TCP的特点</h3>\\n<p>TCP的三个特点：面向连接、可靠、基于字节流。</p>\\n<h3>基于字节流</h3>\\n<p>字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 01 串 。纯裸 TCP 收发的这些 01 串之间是 没有任何边界 的，你根本不知道到哪个地方才算一条完整消息。</p>\\n<p>这便出现了所谓的<code>粘包问题</code>。</p>\\n<p>由于纯裸 TCP 是不能直接拿来用的，所以在这个基础上加入一些 自定义的规则 ，用于区分消息边界 。即消息头和消息体。</p>\\n<h3>消息头和消息体</h3>\\n<p>于是我们会把每条要发送的数据都包装一下，比如加入消息头 ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的消息体 。</p>","autoDesc":true}');export{h as comp,g as data};
